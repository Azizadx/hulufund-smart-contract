{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/BokkyPooBahsDateTimeContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.00 - Contract Instance\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.\n//\n// GNU Lesser General Public License 3.0\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\n// ----------------------------------------------------------------------------\n\nimport \"./BokkyPooBahsDateTimeLibrary.sol\";\n\ncontract BokkyPooBahsDateTimeContract {\n    uint public constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint public constant SECONDS_PER_HOUR = 60 * 60;\n    uint public constant SECONDS_PER_MINUTE = 60;\n    int public constant OFFSET19700101 = 2440588;\n\n    uint public constant DOW_MON = 1;\n    uint public constant DOW_TUE = 2;\n    uint public constant DOW_WED = 3;\n    uint public constant DOW_THU = 4;\n    uint public constant DOW_FRI = 5;\n    uint public constant DOW_SAT = 6;\n    uint public constant DOW_SUN = 7;\n\n    function _now() public view returns (uint timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    function _nowDateTime()\n        public\n        view\n        returns (\n            uint year,\n            uint month,\n            uint day,\n            uint hour,\n            uint minute,\n            uint second\n        )\n    {\n        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary\n            .timestampToDateTime(block.timestamp);\n    }\n\n    function _daysFromDate(\n        uint year,\n        uint month,\n        uint day\n    ) public pure returns (uint _days) {\n        return BokkyPooBahsDateTimeLibrary._daysFromDate(year, month, day);\n    }\n\n    function _daysToDate(\n        uint _days\n    ) public pure returns (uint year, uint month, uint day) {\n        return BokkyPooBahsDateTimeLibrary._daysToDate(_days);\n    }\n\n    function timestampFromDate(\n        uint year,\n        uint month,\n        uint day\n    ) public pure returns (uint timestamp) {\n        return BokkyPooBahsDateTimeLibrary.timestampFromDate(year, month, day);\n    }\n\n    function timestampFromDateTime(\n        uint year,\n        uint month,\n        uint day,\n        uint hour,\n        uint minute,\n        uint second\n    ) public pure returns (uint timestamp) {\n        return\n            BokkyPooBahsDateTimeLibrary.timestampFromDateTime(\n                year,\n                month,\n                day,\n                hour,\n                minute,\n                second\n            );\n    }\n\n    function timestampToDate(\n        uint timestamp\n    ) public pure returns (uint year, uint month, uint day) {\n        (year, month, day) = BokkyPooBahsDateTimeLibrary.timestampToDate(\n            timestamp\n        );\n    }\n\n    function timestampToDateTime(\n        uint timestamp\n    )\n        public\n        pure\n        returns (\n            uint year,\n            uint month,\n            uint day,\n            uint hour,\n            uint minute,\n            uint second\n        )\n    {\n        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary\n            .timestampToDateTime(timestamp);\n    }\n\n    function isValidDate(\n        uint year,\n        uint month,\n        uint day\n    ) public pure returns (bool valid) {\n        valid = BokkyPooBahsDateTimeLibrary.isValidDate(year, month, day);\n    }\n\n    function isValidDateTime(\n        uint year,\n        uint month,\n        uint day,\n        uint hour,\n        uint minute,\n        uint second\n    ) public pure returns (bool valid) {\n        valid = BokkyPooBahsDateTimeLibrary.isValidDateTime(\n            year,\n            month,\n            day,\n            hour,\n            minute,\n            second\n        );\n    }\n\n    function isLeapYear(uint timestamp) public pure returns (bool leapYear) {\n        leapYear = BokkyPooBahsDateTimeLibrary.isLeapYear(timestamp);\n    }\n\n    function _isLeapYear(uint year) public pure returns (bool leapYear) {\n        leapYear = BokkyPooBahsDateTimeLibrary._isLeapYear(year);\n    }\n\n    function isWeekDay(uint timestamp) public pure returns (bool weekDay) {\n        weekDay = BokkyPooBahsDateTimeLibrary.isWeekDay(timestamp);\n    }\n\n    function isWeekEnd(uint timestamp) public pure returns (bool weekEnd) {\n        weekEnd = BokkyPooBahsDateTimeLibrary.isWeekEnd(timestamp);\n    }\n\n    function getDaysInMonth(\n        uint timestamp\n    ) public pure returns (uint daysInMonth) {\n        daysInMonth = BokkyPooBahsDateTimeLibrary.getDaysInMonth(timestamp);\n    }\n\n    function _getDaysInMonth(\n        uint year,\n        uint month\n    ) public pure returns (uint daysInMonth) {\n        daysInMonth = BokkyPooBahsDateTimeLibrary._getDaysInMonth(year, month);\n    }\n\n    function getDayOfWeek(uint timestamp) public pure returns (uint dayOfWeek) {\n        dayOfWeek = BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp);\n    }\n\n    function getYear(uint timestamp) public pure returns (uint year) {\n        year = BokkyPooBahsDateTimeLibrary.getYear(timestamp);\n    }\n\n    function getMonth(uint timestamp) public pure returns (uint month) {\n        month = BokkyPooBahsDateTimeLibrary.getMonth(timestamp);\n    }\n\n    function getDay(uint timestamp) public pure returns (uint day) {\n        day = BokkyPooBahsDateTimeLibrary.getDay(timestamp);\n    }\n\n    function getHour(uint timestamp) public pure returns (uint hour) {\n        hour = BokkyPooBahsDateTimeLibrary.getHour(timestamp);\n    }\n\n    function getMinute(uint timestamp) public pure returns (uint minute) {\n        minute = BokkyPooBahsDateTimeLibrary.getMinute(timestamp);\n    }\n\n    function getSecond(uint timestamp) public pure returns (uint second) {\n        second = BokkyPooBahsDateTimeLibrary.getSecond(timestamp);\n    }\n\n    function addYears(\n        uint timestamp,\n        uint _years\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addYears(timestamp, _years);\n    }\n\n    function addMonths(\n        uint timestamp,\n        uint _months\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(\n            timestamp,\n            _months\n        );\n    }\n\n    function addDays(\n        uint timestamp,\n        uint _days\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, _days);\n    }\n\n    function addHours(\n        uint timestamp,\n        uint _hours\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addHours(timestamp, _hours);\n    }\n\n    function addMinutes(\n        uint timestamp,\n        uint _minutes\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addMinutes(\n            timestamp,\n            _minutes\n        );\n    }\n\n    function addSeconds(\n        uint timestamp,\n        uint _seconds\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addSeconds(\n            timestamp,\n            _seconds\n        );\n    }\n\n    function subYears(\n        uint timestamp,\n        uint _years\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subYears(timestamp, _years);\n    }\n\n    function subMonths(\n        uint timestamp,\n        uint _months\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subMonths(\n            timestamp,\n            _months\n        );\n    }\n\n    function subDays(\n        uint timestamp,\n        uint _days\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subDays(timestamp, _days);\n    }\n\n    function subHours(\n        uint timestamp,\n        uint _hours\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subHours(timestamp, _hours);\n    }\n\n    function subMinutes(\n        uint timestamp,\n        uint _minutes\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subMinutes(\n            timestamp,\n            _minutes\n        );\n    }\n\n    function subSeconds(\n        uint timestamp,\n        uint _seconds\n    ) public pure returns (uint newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subSeconds(\n            timestamp,\n            _seconds\n        );\n    }\n\n    function diffYears(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) public pure returns (uint _years) {\n        _years = BokkyPooBahsDateTimeLibrary.diffYears(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n\n    function diffMonths(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) public pure returns (uint _months) {\n        _months = BokkyPooBahsDateTimeLibrary.diffMonths(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n\n    function diffDays(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) public pure returns (uint _days) {\n        _days = BokkyPooBahsDateTimeLibrary.diffDays(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n\n    function diffHours(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) public pure returns (uint _hours) {\n        _hours = BokkyPooBahsDateTimeLibrary.diffHours(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n\n    function diffMinutes(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) public pure returns (uint _minutes) {\n        _minutes = BokkyPooBahsDateTimeLibrary.diffMinutes(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n\n    function diffSeconds(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) public pure returns (uint _seconds) {\n        _seconds = BokkyPooBahsDateTimeLibrary.diffSeconds(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n}\n"
    },
    "contracts/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   https://aa.usno.navy.mil/faq/JD_formula.html\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint year,\n        uint month,\n        uint day\n    ) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day -\n            32075 +\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\n            4 +\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n            12 -\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n            4 -\n            OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(\n        uint _days\n    ) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int _month = (80 * L) / 2447;\n        int _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(\n        uint year,\n        uint month,\n        uint day\n    ) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n\n    function timestampFromDateTime(\n        uint year,\n        uint month,\n        uint day,\n        uint hour,\n        uint minute,\n        uint second\n    ) internal pure returns (uint timestamp) {\n        timestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            hour *\n            SECONDS_PER_HOUR +\n            minute *\n            SECONDS_PER_MINUTE +\n            second;\n    }\n\n    function timestampToDate(\n        uint timestamp\n    ) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(\n        uint timestamp\n    )\n        internal\n        pure\n        returns (\n            uint year,\n            uint month,\n            uint day,\n            uint hour,\n            uint minute,\n            uint second\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(\n        uint year,\n        uint month,\n        uint day\n    ) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n\n    function isValidDateTime(\n        uint year,\n        uint month,\n        uint day,\n        uint hour,\n        uint minute,\n        uint second\n    ) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n\n    function getDaysInMonth(\n        uint timestamp\n    ) internal pure returns (uint daysInMonth) {\n        (uint year, uint month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n\n    function _getDaysInMonth(\n        uint year,\n        uint month\n    ) internal pure returns (uint daysInMonth) {\n        if (\n            month == 1 ||\n            month == 3 ||\n            month == 5 ||\n            month == 7 ||\n            month == 8 ||\n            month == 10 ||\n            month == 12\n        ) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(\n        uint timestamp\n    ) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = ((_days + 3) % 7) + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(\n        uint timestamp,\n        uint _years\n    ) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMonths(\n        uint timestamp,\n        uint _months\n    ) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        month += _months;\n        year += (month - 1) / 12;\n        month = ((month - 1) % 12) + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addDays(\n        uint timestamp,\n        uint _days\n    ) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addHours(\n        uint timestamp,\n        uint _hours\n    ) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMinutes(\n        uint timestamp,\n        uint _minutes\n    ) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addSeconds(\n        uint timestamp,\n        uint _seconds\n    ) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(\n        uint timestamp,\n        uint _years\n    ) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp <= timestamp);\n    }\n\n    function subMonths(\n        uint timestamp,\n        uint _months\n    ) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = (yearMonth % 12) + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp <= timestamp);\n    }\n\n    function subDays(\n        uint timestamp,\n        uint _days\n    ) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subHours(\n        uint timestamp,\n        uint _hours\n    ) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subMinutes(\n        uint timestamp,\n        uint _minutes\n    ) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subSeconds(\n        uint timestamp,\n        uint _seconds\n    ) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n\n    function diffMonths(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth, ) = _daysToDate(\n            fromTimestamp / SECONDS_PER_DAY\n        );\n        (uint toYear, uint toMonth, ) = _daysToDate(\n            toTimestamp / SECONDS_PER_DAY\n        );\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n\n    function diffDays(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n\n    function diffHours(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n\n    function diffMinutes(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n\n    function diffSeconds(\n        uint fromTimestamp,\n        uint toTimestamp\n    ) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n"
    },
    "contracts/Equb.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./BokkyPooBahsDateTimeContract.sol\";\nimport \"./PriceConverter.sol\";\n\ncontract Equb {\n    using SafeMath for uint;\n    using PriceConverter for uint256;\n\n    uint256 public numberOfPools = 0;\n    address timeContractAddress = 0x4385483b852D01655A7e760F616725C0c3db9873;\n    BokkyPooBahsDateTimeContract timeContract =\n        BokkyPooBahsDateTimeContract(timeContractAddress);\n    AggregatorV3Interface public priceFeed;\n    struct PoolData {\n        address equbAddress;\n        string poolName;\n        string poolImage;\n    }\n\n    struct Pool {\n        address equbAddress;\n        string name;\n        string profileUrl;\n        string email;\n        string description;\n        uint contributionAmount; //will be save in wei\n        uint contributionDate; //5\n        uint equbBalance;\n        uint contributionSkipCount; //no need in frontend;\n        string website;\n        string twitterUrl;\n        string facebookUrl;\n        string telegramUrl;\n        address[] members;\n    }\n\n    Pool[] public pools;\n    mapping(address => mapping(address => bool)) public contributions;\n\n    event ContributionEvent(\n        address member,\n        uint256 contributeAmount,\n        uint256 daoBalance\n    );\n\n    event SkipContributionEvent(address member, address equbAddress);\n    event MemberRemovedEvent(address member, address equbAddress);\n    event NextContributionTime(uint time);\n    event Success(string message);\n\n    constructor() {\n        priceFeed = AggregatorV3Interface(\n            0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e\n        );\n    }\n\n    function hasContributed(\n        address equbAddress,\n        address member\n    ) public view returns (bool) {\n        return contributions[equbAddress][member];\n    }\n\n    function createEqub(\n        string memory _name,\n        string memory _profileUrl,\n        string memory _email,\n        string memory _description,\n        uint _contributionAmount,\n        uint _contributionDate,\n        string memory _website,\n        string memory _twitterUrl,\n        string memory _facebookUrl,\n        string memory _telegramUrl,\n        address[] memory _members\n    ) public {\n        require(_members.length <= 10, \"Maximum of 10 members can contribute\");\n        // Check if the sender (creator) has already created a pool\n        for (uint i = 0; i < pools.length; i++) {\n            require(\n                pools[i].equbAddress != msg.sender,\n                \"Only one pool creation per address is allowed\"\n            );\n        }\n        pools.push(\n            Pool(\n                msg.sender,\n                _name,\n                _profileUrl,\n                _email,\n                _description,\n                _contributionAmount * 1e18,\n                _contributionDate,\n                0 * 1e18,\n                0,\n                _website,\n                _twitterUrl,\n                _facebookUrl,\n                _telegramUrl,\n                _members\n            )\n        );\n        numberOfPools += 1;\n        // Initialize contribution records for members\n        for (uint i = 0; i < _members.length; i++) {\n            contributions[msg.sender][_members[i]] = false;\n        }\n    }\n\n    function getPool(\n        address equbAddress\n    )\n        public\n        view\n        returns (\n            address _equbAddress,\n            string memory _name,\n            string memory _profileUrl,\n            string memory _email,\n            string memory _description,\n            uint _contributionAmount,\n            uint _contributionDate,\n            uint _equbBalance,\n            // uint _contributionSkipCount,\n            string memory _website,\n            string memory _twitterUrl,\n            string memory _facebookUrl,\n            string memory _telegramUrl,\n            address[] memory _members\n        )\n    {\n        for (uint i = 0; i < pools.length; i++) {\n            if (pools[i].equbAddress == equbAddress) {\n                return (\n                    pools[i].equbAddress,\n                    pools[i].name,\n                    pools[i].profileUrl,\n                    pools[i].email,\n                    pools[i].description,\n                    PriceConverter.getConversionRate(\n                        pools[i].contributionAmount,\n                        priceFeed\n                    ),\n                    pools[i].contributionDate,\n                    PriceConverter.getConversionRate(\n                        pools[i].equbBalance,\n                        priceFeed\n                    ),\n                    // pools[i].contributionSkipCount,\n                    pools[i].website,\n                    pools[i].twitterUrl,\n                    pools[i].facebookUrl,\n                    pools[i].telegramUrl,\n                    pools[i].members\n                );\n            }\n        }\n        revert(\"No pool created by this address\");\n    }\n\n    function getPoolByMember(\n        address member\n    ) public view returns (PoolData[] memory) {\n        PoolData[] memory poolData = new PoolData[](numberOfPools);\n        uint k = 0;\n        for (uint i = 0; i < pools.length; i++) {\n            for (uint j = 0; j < pools[i].members.length; j++) {\n                if (pools[i].members[j] == member) {\n                    poolData[k] = PoolData(\n                        pools[i].equbAddress,\n                        pools[i].name,\n                        pools[i].profileUrl\n                    );\n                    k++;\n                }\n            }\n        }\n        require(k > 0, \"Member not found in any pool.\");\n        return poolData;\n    }\n\n    function contribution(address equbAddress, address member) public payable {\n        // Find the pool by equbAddress\n\n        uint poolIndex = getPoolIndex(equbAddress);\n        uint contAmount = msg.value.getConversionRate(priceFeed);\n        require(\n            contAmount == pools[poolIndex].contributionAmount,\n            \"Contribution amount is incorrect.\"\n        );\n\n        //check the member skip count\n        uint skipCount = getRemainingSkipCount(equbAddress, member);\n        if (skipCount < 3) {\n            removeMember(equbAddress, member);\n            revert(\n                \"You have skipped the contribution for three times, You will be removed from the pool.\"\n            );\n        }\n\n        //Check the current date and compare it to the contribution date\n        uint256 today = timeContract.getDay(block.timestamp);\n        // uint256 month = BokkyPooBahsDateTimeLibrary.getMonth(block.timestamp);\n        // uint256 year = BokkyPooBahsDateTimeLibrary.getYear(block.timestamp);\n        //if the day pass\n        if (today > pools[poolIndex].contributionDate) {\n            //check if this is first time that member skip contribution\n            if (contributions[equbAddress][member]) {\n                //increment the skip count\n                pools[poolIndex].contributionSkipCount += 1;\n                //Emit event\n                emit SkipContributionEvent(member, equbAddress);\n                if (skipCount == 2) {\n                    //remove the member from the pool\n                    removeMember(equbAddress, member);\n                    emit MemberRemovedEvent(member, equbAddress);\n                }\n            }\n        } else {\n            // Add the contribution amount to the pool balance\n            pools[poolIndex].equbBalance += contAmount;\n\n            // Mark the contribution as done\n            contributions[equbAddress][member] = true;\n\n            // Emit the Contribution event\n            emit ContributionEvent(\n                member,\n                contAmount,\n                pools[poolIndex].equbBalance\n            );\n            emit NextContributionTime(pools[poolIndex].contributionDate);\n        }\n    }\n\n    function getPoolIndex(address equbAddress) private view returns (uint) {\n        for (uint i = 0; i < pools.length; i++) {\n            if (pools[i].equbAddress == equbAddress) {\n                return i;\n            }\n        }\n        revert(\"Pool not found\");\n    }\n\n    function getRemainingSkipCount(\n        address equbAddress,\n        address member\n    ) public view returns (uint) {\n        // Find the pool by equbAddress\n        uint poolIndex;\n        for (uint i = 0; i < pools.length; i++) {\n            if (pools[i].equbAddress == equbAddress) {\n                poolIndex = i;\n                break;\n            }\n        }\n        // Check if the member has contributed\n        if (!contributions[equbAddress][member]) {\n            // If the member has not contributed, skipsLeft = 3\n            return 3;\n        } else {\n            // If the member has contributed, calculate skipsLeft\n            return 3 - pools[poolIndex].contributionSkipCount;\n        }\n    }\n\n    function removeMember(address equbAddress, address member) internal {\n        for (uint i = 0; i < pools.length; i++) {\n            if (pools[i].equbAddress == equbAddress) {\n                address[] memory members = pools[i].members;\n                for (uint j = 0; j < members.length; j++) {\n                    if (members[j] == member) {\n                        //delete the member from the array\n                        delete members[j];\n                        //update the member array\n                        pools[i].members = members;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConverter {\n    function getPrice(\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        //ABI\n        //Address 0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e\n        // AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e); no need anymore\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        return uint256(price * 1e10); //1**10 == 10000000000\n    }\n\n    // function getVersion() internal view returns (uint256) {\n    //     AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);\n    //     return priceFeed.version();\n    // }\n\n    function getConversionRate(\n        uint256 ethAmount,\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        uint256 ethPrice = getPrice(priceFeed);\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;\n        return ethAmountInUsd;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}